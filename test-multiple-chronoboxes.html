<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Chrono-Boxes Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .chrono-box {
            border: 2px solid #007bff;
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
        }
        .chrono-box h3 {
            margin-top: 0;
            color: #007bff;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
            font-size: 12px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .store-data {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
    </style>
</head>
<body>
    <h1>Multiple Chrono-Boxes Test</h1>
    
    <div class="test-section info">
        <h2>Test Overview</h2>
        <p>This page tests multiple chrono-boxes with unified plugin stores and worker communication.</p>
        <p>All chrono-boxes on the same page should share the same tabId and communicate via BroadcastChannel.</p>
    </div>

    <div class="test-section">
        <h2>Test Controls</h2>
        <button onclick="runIsolationTest()">Run Unified Tab Test</button>
        <button onclick="checkWorkerCommunication()">Check Worker Communication</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>

    <div id="test-results"></div>

    <!-- Chrono-Box Instances -->
    <div class="chrono-box">
        <h3>Chrono-Box 1</h3>
        <div data-block-name="chrono-box" data-schedule-id="test-schedule-1"></div>
    </div>

    <div class="chrono-box">
        <h3>Chrono-Box 2</h3>
        <div data-block-name="chrono-box" data-schedule-id="test-schedule-2"></div>
    </div>

    <script type="module">
        // Mock metadata for testing
        window.getMetadata = (key) => {
            if (key === 'schedules') {
                return JSON.stringify({
                    'test-schedule-1': [
                        {
                            time: '09:00',
                            title: 'Session 1',
                            pathToFragment: '/fragment-1',
                            metadata: [{ key: 'video.url' }],
                            'mobileRider': [{ sessionId: 'session-1' }]
                        }
                    ],
                    'test-schedule-2': [
                        {
                            time: '10:00',
                            title: 'Session 2',
                            pathToFragment: '/fragment-2',
                            metadata: [{ key: 'speaker.name' }],
                            'mobileRider': [{ sessionId: 'session-2' }]
                        }
                    ]
                });
            }
            return null;
        };

        // Mock lana for logging
        window.lana = {
            log: (message) => console.log('LANA:', message)
        };

        // Mock crypto for UUID generation
        if (!window.crypto) {
            window.crypto = {
                randomUUID: () => 'test-uuid-' + Math.random().toString(36).substr(2, 9)
            };
        }

        // Test functions
        window.runIsolationTest = async () => {
            const results = document.getElementById('test-results');
            results.innerHTML = '<div class="info"><h3>Running Unified Tab Test...</h3></div>';

            try {
                // Test 1: Import plugins
                const { default: metadataPlugin } = await import('./events/features/timing-framework/plugins/metadata/plugin.js');
                const { default: mobileRiderPlugin } = await import('./events/features/timing-framework/plugins/mobile-rider/plugin.js');
                
                results.innerHTML += `<div class="success"><p>✅ Plugins imported successfully</p></div>`;

                // Test 2: Create separate stores with shared tabId
                const schedule1 = [
                    {
                        metadata: [{ key: 'video.url' }],
                        'mobileRider': [{ sessionId: 'session-1' }]
                    }
                ];
                const schedule2 = [
                    {
                        metadata: [{ key: 'speaker.name' }],
                        'mobileRider': [{ sessionId: 'session-2' }]
                    }
                ];

                // Clear any existing tabId to start fresh
                sessionStorage.removeItem('chrono-box-tab-id');

                const metadataStore1 = metadataPlugin(schedule1);
                const metadataStore2 = metadataPlugin(schedule2);
                const mobileRiderStore1 = mobileRiderPlugin(schedule1);
                const mobileRiderStore2 = mobileRiderPlugin(schedule2);

                results.innerHTML += `<div class="success"><p>✅ Created store instances</p></div>`;

                // Test 3: Verify stores share the same tabId
                const tabId1 = sessionStorage.getItem('chrono-box-tab-id');
                if (tabId1) {
                    results.innerHTML += `<div class="success"><p>✅ Tab ID created and stored: ${tabId1}</p></div>`;
                } else {
                    results.innerHTML += `<div class="error"><p>❌ Tab ID not found in sessionStorage</p></div>`;
                }

                // Test 4: Verify stores can communicate via BroadcastChannel
                metadataStore1.set('shared.key', 'value-from-store1');
                const valueFromStore2 = metadataStore2.get('shared.key');
                
                if (valueFromStore2 === 'value-from-store1') {
                    results.innerHTML += `<div class="success"><p>✅ Store communication verified - stores share data via BroadcastChannel</p></div>`;
                } else {
                    results.innerHTML += `<div class="error"><p>❌ Store communication failed - stores are not sharing data</p></div>`;
                }

                // Test 5: Verify mobile rider stores also share data
                mobileRiderStore1.set('shared-session', true);
                const sessionFromStore2 = mobileRiderStore2.get('shared-session');
                
                if (sessionFromStore2 === true) {
                    results.innerHTML += `<div class="success"><p>✅ Mobile rider store communication verified</p></div>`;
                } else {
                    results.innerHTML += `<div class="error"><p>❌ Mobile rider store communication failed</p></div>`;
                }

                results.innerHTML += `<div class="success"><h4>✅ Unified Tab Test Passed</h4></div>`;

            } catch (error) {
                results.innerHTML += `<div class="error"><h4>❌ Unified Tab Test Failed</h4><p>${error.message}</p></div>`;
            }
        };

        window.checkWorkerCommunication = async () => {
            const results = document.getElementById('test-results');
            results.innerHTML = '<div class="info"><h3>Checking Worker Communication...</h3></div>';

            try {
                // Test 1: Check if Worker API is available
                if (typeof Worker !== 'undefined') {
                    results.innerHTML += `<div class="success"><p>✅ Worker API is available</p></div>`;
                } else {
                    results.innerHTML += `<div class="error"><p>❌ Worker API is not available</p></div>`;
                    return;
                }

                // Test 2: Check if BroadcastChannel API is available
                if (typeof BroadcastChannel !== 'undefined') {
                    results.innerHTML += `<div class="success"><p>✅ BroadcastChannel API is available</p></div>`;
                } else {
                    results.innerHTML += `<div class="error"><p>❌ BroadcastChannel API is not available</p></div>`;
                    return;
                }

                // Test 3: Test BroadcastChannel communication
                const channel = new BroadcastChannel('test-channel');
                let messageReceived = false;
                
                channel.onmessage = (event) => {
                    if (event.data === 'test-message') {
                        messageReceived = true;
                    }
                };

                channel.postMessage('test-message');
                
                // Wait a bit for the message to be processed
                setTimeout(() => {
                    if (messageReceived) {
                        results.innerHTML += `<div class="success"><p>✅ BroadcastChannel communication works</p></div>`;
                    } else {
                        results.innerHTML += `<div class="error"><p>❌ BroadcastChannel communication failed</p></div>`;
                    }
                    channel.close();
                }, 100);

                results.innerHTML += `<div class="success"><h4>✅ Worker Communication Test Passed</h4></div>`;

            } catch (error) {
                results.innerHTML += `<div class="error"><h4>❌ Worker Communication Test Failed</h4><p>${error.message}</p></div>`;
            }
        };

        window.clearResults = () => {
            document.getElementById('test-results').innerHTML = '';
        };

        // Auto-run isolation test on page load
        setTimeout(() => {
            window.runIsolationTest();
        }, 1000);
    </script>
</body>
</html> 
